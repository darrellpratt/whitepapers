{"name":"Whitepapers","tagline":"","body":"# \"Building\" Modern Web Applications\r\n\r\n> Darrell Pratt, Architect Leader, GBS\r\n\r\n\r\n## Executive Summary\r\n\r\nWith the increase in popularity of one page web applications, the JavaScript lying underneath these applications has grown more advanced. The number of libraries that are used with these applications and the manner that they can be packaged and deployed has advanced a great deal in the last year. This paper will detail some of the more popular build chains that are used throughout the JavaScript developer community and give details as to how these tools can increase developer productivity and deliver more reliable applications.\r\n\r\n\r\n## Problem Statement\r\n\r\nModern web applications include a wide variety of assets which must be packaged in various ways in order to deliver a good experience to the end user.  From source minification, dynamic module loaders, SASS and LESS compilers, CoffeeScript transpilation and dependency management, the build process and application lifecycle management has become increasingly complex.\r\n\r\n## Dependency Management\r\n\r\n### Bower\r\n\r\nA few tools exist now that provide a solution for dependency management in a way similar to Maven in Java. The primary tool in this space is Bower. Bower is used by many other build frameworks such as Twitter's bootstrap and Google's Yeoman.  Bower uses a simple manifest file to specify a set of libraries and their versions which are required by the application.  Bower uses GitHub to house the libraries not unlike Maven with its central repository.\r\n\r\nBower uses a file named bower.json in the root directory of the project to specify the dependencies.  This file has a simple format shown below.\r\n\r\n#### Configuration Sample\r\n```\r\n{\r\n  \"name\": \"client\",\r\n  \"version\": \"0.0.0\",\r\n  \"dependencies\": {\r\n    \"angular\": \"1.2.6\",\r\n    \"json3\": \"~3.2.6\",\r\n    \"es5-shim\": \"~2.1.0\",\r\n    \"jquery\": \"~1.10.2\",\r\n    \"sass-bootstrap\": \"~3.0.2\",\r\n    \"angular-resource\": \"1.2.6\",\r\n    \"angular-cookies\": \"1.2.6\",\r\n    \"angular-sanitize\": \"1.2.6\",\r\n    \"angular-route\": \"1.2.6\",\r\n    \"underscore\": \"1.6\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"angular-mocks\": \"1.2.6\",\r\n    \"angular-scenario\": \"1.2.6\"\r\n  }\r\n}\r\n```\r\n\r\nThe above configuration lists information about the application in the first object block.  This can be used for documentation purposes and build information if wanted. The dependencies section list the libraries by name and version that are needed for the application to function at runtime in the browser.  The devDependencies section list libraries which are used during testing of the application.\r\n\r\nWith this configuration file, the developer has a central location that manages the dependencies of the project and this file itself can be managed under any version control system.\r\n\r\n#### Installation\r\n\r\nInstallation of bower depends upon Node Package Manager (npm).  It would be beyond the scope of this paper to cover the installation of node and npm, but my other whitepaper on nodejs does cover this subject.\r\n\r\n```\r\nnpm install -g bower\r\n```\r\n\r\nAll dependencies required by bower are installed by npm and the -g flag will make the command available to all users.\r\n\r\n\r\n#### General Usage\r\n\r\nBower installs via npm (Node Package module) and provides a command line tool which gives the user a set of useful operations. \r\n\r\n* **bower install** - _will install any packages listed in the bower.json file_\r\n* **bower init** - _will create a new scaffolded bower.json file for a project_\r\n* **bower search** - _will look for a named package in the public repository_\r\n* **bower update** - _will update any packages installed locally to the lastest versions_\r\n\r\n![Bower Command Line Options][bowerHelp]\r\n\r\n\r\n## Build Systems\r\n\r\n### Grunt.js\r\n\r\nGrunt.js is described as a task runner that can automate common build tasks.  Many plugins are available and the community is quite large.  Plugins range from minification, jshinting, test runners, css compilers to custom plugins which can deploy to cloud providers.\r\n\r\n#### Installation\r\n\r\n```\r\nnpm install -g grunt-cli\r\n```\r\n\r\nThis command will install of the necessary dependencies and will include the grunt command line tool for all users.\r\n\r\n#### Configuration\r\n\r\nGrunt relies on a JavaScript based configuration file (Gruntfile.js) to run a set of tasks. Generally tasks all take the same form and are strung together much like Ant or Gradle commands.  A configuration file is shown below.\r\n\r\n```\r\nmodule.exports = function(grunt) {\r\n\r\n  grunt.initConfig({\r\n    pkg: grunt.file.readJSON('package.json'),\r\n    concat: {\r\n      options: {\r\n        separator: ';'\r\n      },\r\n      dist: {\r\n        src: ['src/**/*.js'],\r\n        dest: 'dist/<%= pkg.name %>.js'\r\n      }\r\n    },\r\n    uglify: {\r\n      options: {\r\n        banner: '/*! <%= pkg.name %> <%= grunt.template.today(\"dd-mm-yyyy\") %> */\\n'\r\n      },\r\n      dist: {\r\n        files: {\r\n          'dist/<%= pkg.name %>.min.js': ['<%= concat.dist.dest %>']\r\n        }\r\n      }\r\n    },\r\n    qunit: {\r\n      files: ['test/**/*.html']\r\n    },\r\n    jshint: {\r\n      files: ['Gruntfile.js', 'src/**/*.js', 'test/**/*.js'],\r\n      options: {\r\n        // options here to override JSHint defaults\r\n        globals: {\r\n          jQuery: true,\r\n          console: true,\r\n          module: true,\r\n          document: true\r\n        }\r\n      }\r\n    },\r\n    watch: {\r\n      files: ['<%= jshint.files %>'],\r\n      tasks: ['jshint', 'qunit']\r\n    }\r\n  });\r\n\r\n\r\n  grunt.registerTask('test', ['jshint', 'qunit']);\r\n\r\n  grunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']);\r\n\r\n};\r\n```\r\n\r\n#### Command Line View\r\n\r\nThe Grunt command is quite similar to Ant or Gradle in that it primarly represents whatever tasks are present in the configuration file.  Running the command with no option will run the default task; however, running the command with a task name will run only that command and its predecessors.\r\n\r\n![Grunt Command][grunt]\r\n\r\n\r\n\r\n### Gulp.js \r\n\r\nGulp.js is a similar build system to Grunt.  It is a newer framework and it has one major difference with Grunt. Gulp.js makes use of Nodejs streams for its entire build system. Rather than using tasks as units of work as Grunt does, Gulp uses the stream technique to pipe one set of files through a pipeline of tasks.  This is best illustrated with a look at a gulp configuration file.\r\n\r\n#### Installation\r\n\r\n```\r\nnpm install -g gulp\r\n```\r\n\r\nTo install gulp as a dev dependency for your application, run the following command in your project root directory.\r\n\r\n```\r\nnpm install --save-dev gulp\r\n```\r\n\r\n#### Configuration\r\n\r\n```\r\n// Load plugins\r\nvar gulp = require('gulp'),\r\n    sass = require('gulp-ruby-sass'),\r\n    autoprefixer = require('gulp-autoprefixer'),\r\n    minifycss = require('gulp-minify-css'),\r\n    jshint = require('gulp-jshint'),\r\n    uglify = require('gulp-uglify'),\r\n    imagemin = require('gulp-imagemin'),\r\n    rename = require('gulp-rename'),\r\n    clean = require('gulp-clean'),\r\n    concat = require('gulp-concat'),\r\n    notify = require('gulp-notify'),\r\n    cache = require('gulp-cache'),\r\n    livereload = require('gulp-livereload');\r\n\r\n// Styles\r\ngulp.task('styles', function() {\r\n  return gulp.src('src/styles/main.scss')\r\n    .pipe(sass({ style: 'expanded', }))\r\n    .pipe(autoprefixer('last 2 version', ''))\r\n    .pipe(gulp.dest('dist/styles'))\r\n    .pipe(rename({ suffix: '.min' }))\r\n    .pipe(minifycss())\r\n    .pipe(gulp.dest('dist/styles'))\r\n    .pipe(notify({ message: 'Styles task complete' }));\r\n});\r\n\r\n// Scripts\r\ngulp.task('scripts', function() {\r\n  return gulp.src('src/scripts/**/*.js')\r\n    .pipe(jshint('.jshintrc'))\r\n    .pipe(jshint.reporter('default'))\r\n    .pipe(concat('main.js'))\r\n    .pipe(gulp.dest('dist/scripts'))\r\n    .pipe(rename({ suffix: '.min' }))\r\n    .pipe(uglify())\r\n    .pipe(gulp.dest('dist/scripts'))\r\n    .pipe(notify({ message: 'Scripts task complete' }));\r\n});\r\n\r\n// Clean\r\ngulp.task('clean', function() {\r\n  return gulp.src(['dist/styles', 'dist/scripts', 'dist/images'], {read: false})\r\n    .pipe(clean());\r\n});\r\n\r\n// Default task\r\ngulp.task('default', ['clean'], function() {\r\n    gulp.start('styles', 'scripts', 'images');\r\n});\r\n\r\n// Watch\r\ngulp.task('watch', function() {\r\n\r\n  // Watch .scss files\r\n  gulp.watch('src/styles/**/*.scss', ['styles']);\r\n\r\n  // Watch .js files\r\n  gulp.watch('src/scripts/**/*.js', ['scripts']);\r\n\r\n  // Watch image files\r\n  gulp.watch('src/images/**/*', ['images']);\r\n\r\n  // Create LiveReload server\r\n  var server = livereload();\r\n\r\n  // Watch any files in dist/, reload on change\r\n  gulp.watch(['dist/**']).on('change', function(file) {\r\n    server.changed(file.path);\r\n  });\r\n\r\n});\r\n\r\n```\r\n\r\nBased upon the different file sytaxes the reader can determine which system they might prefer. There is considerable weight behind the Gulp.js system currently with its use of streams and the overall direction of the direction of nodejs with its emphasis on streams as well.\r\n\r\n\r\n## Scaffolding Systems\r\n\r\n### Yeoman\r\n\r\nYeoman is a tool that is built to automate front-end web workflows.  It includes tools which we have already covered (Grunt and Bower) but adds a new tool called Yo. The focus of Yeoman is to scaffold out an application based upon inputs to its build system.  This is not unlike the methodology in Ruby On Rails applications.\r\n\r\nYeoman includes several generators written by both the core team and community members and there is a well documented API provided to create new generators.\r\n\r\nThe framework makes use of these generators to scaffold an application structure for the user.  By selecting a few options, a user can create a well documented and well structured front-end web application.  Some of the most popular generators are included for AngularJS, Backbone, Polymer, Ember and test suites such as Karma and Jasmine.\r\n\r\n\r\n#### Installation\r\n\r\n```\r\nnpm install -g yo\r\n```\r\n\r\nTo install any given Yeoman generator run the following command.\r\n\r\n```js\r\n// basic web app generator\r\nnpm install -g generator-webapp\r\n// angular generator\r\nnpm install -g generator-angular\r\n```\r\n\r\n#### Typical Usage\r\n\r\nThe simplest way to use Yeoman would be to generate a scaffold for a new front-end web application.  In order to perform this action, the user would run the following commands.\r\n\r\n![Yeoman Generator Command][yo1]\r\n\r\n![Yeoman Command Continued][yo2]\r\n\r\nAt this point, Yeoman is complete and the user only needs to run bower to install the dependencies.\r\n\r\n![Bower Configuration][yo3]\r\n\r\n## Conclusion\r\n\r\nThis paper has detailed a list of tools that will make the front-end web application developer more effecient in their build processes.  These tools are all fairly new, but have very active communities around them and with applications like GulpJS evolving the build tools, this is a space that is worth exploring going forward.\r\n\r\nI believe the Yeoman framework with its generators could also be very useful to Nielsen as engineering could create their own set of generators that are specific to their application needs.\r\n\r\n[bowerHelp]: https://raw.githubusercontent.com/darrellpratt/b2at/master/client/app/images/bowerHelp.png\r\n\r\n[grunt]: https://raw.githubusercontent.com/darrellpratt/b2at/master/client/app/images/grunt.png\r\n\r\n[yo1]: https://raw.githubusercontent.com/darrellpratt/b2at/master/client/app/images/yo1.png\r\n\r\n[yo2]: https://raw.githubusercontent.com/darrellpratt/b2at/master/client/app/images/yo2.png\r\n\r\n[yo3]: https://raw.githubusercontent.com/darrellpratt/b2at/master/client/app/images/yo3.png\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}